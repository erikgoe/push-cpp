#prelude(push)

struct A {
    foo:u32,
    bar:u32,
}

trait op::Add {
    add(self, other)
}

impl op::Add for A {
    add(self:&Self, other:Self) {
        self.foo + other.foo
    }
}

std::op::is_equal(left:mut&u32, right:&u32) -> () {
}
std::op::assignment(left:mut&u32, right:&u32) -> () {
}
std::op::addition(left:&u32, right:&u32) -> u32 {
}
std::op::division(left:&u32, right:&u32) -> u32 {
}
std::op::bigger(left:&u32, right:&u32) -> bool {
}

println(str) -> () {}

fn() -> (u32,u64) {
    let a:u32 = 4;
    a+inc(3)
}

inc(val) { val + 1 }

g() -> u32 {
    let x:A = 1;
    x.add(1);
    let A{a,1} = x;

    let x:A = A{42,40+3};
    if x.bar / 2 > 21 {
        println("lies!");
    } else {
        println("truth");
    }
    x.add(A{1,1});
    x.foo // TODO lifetime error
}

/*
x() {
    let b:mut = 3;
    {
        let a = A{1,2};
        b = y(a);
    }   
    b
}

y(val:&A) {
    val.foo
}*/
