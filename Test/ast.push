#prelude(push)

///// Standard stuff

trait std::num::Integer{}
trait std::base::Iterator{}

impl std::num::Integer for u16{}
impl std::num::Integer for u32{}
impl std::num::Integer for u64{}

#stub()
#drop_handler()
std::drop<T>(to_drop:T) -> () {
}

#stub()
std::op::is_equal(left:mut&u32, right:&u32) -> () {
}
#stub()
std::op::assignment(left:mut&u32, right:&u32) -> () {
}
#stub()
std::op::addition(left:&u32, right:&u32) -> u32 {
}
#stub()
std::op::division(left:&u32, right:&u32) -> u32 {
}
#stub()
std::op::bigger(left:&u32, right:&u32) -> bool {
}
#stub()
std::op::in_operator(collection:&u32) -> std::base::Iterator {
}
#stub()
std::itr::valid(itr:&std::base::Iterator) -> bool {
}
#stub()
std::itr::get(itr:&std::base::Iterator) -> u32 {
}
#stub()
std::itr::next(itr:&std::base::Iterator) -> () {
}


///// Code

struct A {
    foo:u32,
    bar:u32,
}

trait op::Add {
    add(self, other)
}

impl op::Add for A {
    add(self:&Self, other:Self) {
        self.foo + other.foo
    }
}

//println(str:std::str::String) -> () {}

fn() -> u32 {
    let a:u32 = 4;
    fn_t<u32, u64>( 1, 2 );
    inc( 3 )
}

fn_t<T, S> ( param1:&T, param2:&S ) -> T
    where (T: std::num::Integer) {
    param1
}

inc(val:u32) -> u32 { val + 1 }
//inc(val:u32) -> () {}
//inc(val:A) {}

/*g() -> u32 {
    let x:A = A{1, 2};
    x.add(A{3,4});
    let A{a,b} = x;

    let x:A = A{42,40+3};
    if x.bar / 2 > 21 {
        println("lies!");
    } else {
        println("truth");
    }
    x.add(A{1,1});
    x.foo // TODO lifetime error
}*/

/*h() {
    //let itr:std::base::Iterator = 1;
    for i in 0 { // Don't mind the type
        // stuff
    }
}*/

/*x() {
    let b:mut u32 = 3;
    {
        let a = A{1,2};
        b = y(a);
    }   
    b
}

y(val:&A) {
    val.foo
}*/
