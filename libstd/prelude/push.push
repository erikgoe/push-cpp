// Copyright 2019 Erik GÃ¶tzfried
// Licensed under the Apache License, Version 2.0( the "License" );
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/* This file is an example implementation of the prelude for a 32 bit platform.
 */

/* Rules
 * MCI functions are only valid in prelude files or in prelude-included std-lib files,
 * MCI functions (names):
 * - define_mci_rule: very basic rules, which define the language syntax.
 * - create_mci_logic: used in methods to define e. g. very low-level operations like integer addition.
 * - define_mci_optimization: take in a push-lambda which contain optimizations on the AST and an optimization execution level to be used conditionally
 * Syntax:
 *     MCI syntax is independent from the prelude
 *     MCI functions always start with the name, then the parameters in parenthesis and end with a semicolon.
 *     The parameters of MCI rules always depend on their MCI, which is the first parameter.
 *     The parameters are separated by commas, sub parameters by spaces.
 *     MCI parameters may not be empty.
 *     Strings and characters are always escaped and written in double quotes.
 *     If a string is expected for e. g. a keyword, you can either write it in double quotes or use a predefined name in most cases. You can also use the "or" keyword to define multiple matching strings.
 *     The "->" syntax is often used to define which token/AST has which meaning in the syntax rule. The names are defines by the MCI instruction and the specified layout type.
 * Multiple definitions for one MCI are allowed.
 * Include other prelude files with "#prelude(<file>)" and std-library files with "#include(<file>)". This is only possible in a prelude file.
 * Only a std-library file included this way is able to use the global "create_mci_logic()" function. TODO define example for primitive type operators
 * 
 */

/* Operator precedence table
 *  1. function call, template, array-, scope-, member access
 *  2. !(not), ~(bit not), -(unary), +(unary), &(ref), type_of, as_tuple, ++(prefix), --(prefix); all right to left
 *  3. ++(postfix), --(postfix)
 *  4. as(cast), :(type definitions)
 *  5. *, /, %
 *  6. +, -
 *  7. &
 *  8. '(bit xor)
 *  9. |
 * 10. <<, >>
 * 10.5 ..(range)
 * 11. in(iterator, collection)
 * 12. <, <=, >, >=
 * 13. ==, !=
 * 14. &&
 * 15. ||
 * 16. =, +=, -=, *=, /=, %=, &=, '=, |=, <<=, >>=, :=; all right to left
 * 17. =>(pair)
 * 18. ,(comma)
 */

/* TODO list
 * dynamic blocks
 * lambdas
 * check precedence for other operations like if/for/struct and update the precedence in the code
 * any, int, float as compound types/traits
 * tuples (with parenthesis syntax)
 * module, crate syntax
 * static statements, compilerhandler
 * with-keyword
 * repeat keyword: like continue but without increment
 * is-of-type operator with a lower precedence than e. g. & operator
 *     also the & operator impl for Types may combine them in manner to be used in trait bounds
 * 
 */

// Most basic rules
define_mci_rule( EXPRESSION_RULES, divide semicolon, block left_brace right_brace, term left_parenthesis right_parenthesis ); // list of rules for expressions: semicolons divide expressions/statements, braces combine a block, parenthesis combine a term
define_mci_rule( IDENTIFIER_RULES, no_spaces, unused begin "_" ); // define rules for identifiers
define_mci_rule( IDENTIFIER_CASE, functions snake, method snake, variables snake, modules snake, struct pascal, trait pascal ); // define how which identifiers have to be written

// Basic literal rules
define_mci_rule( LITERAL_CHARACTER_ESCAPES, newline "\\n", horizontal_tab "\\t", vertical_tab "\\v", carriage_return "\\r", backslash "\\\\", quote "\\\'", double_quotes "\\\"", null "\\0" ); // Possible character escapes in strings or single characters

// Character ranges
define_mci_rule( NEW_RANGE, identifier, "_" ); // additional identifier characters
define_mci_rule( NEW_RANGE, opt_identifier, "0" "9" ); // additional allowed characters
define_mci_rule( NEW_RANGE, integer, "_", "0" "9" );
define_mci_rule( NEW_RANGE, whitespace, " ", "\n", "\r", "\t" );

// Comment rules
define_mci_rule( NEW_LEVEL, COMMENT, b, "/*" "*/", overlay b );
define_mci_rule( NEW_LEVEL, COMMENT_LINE, ln, "//" "\n" );
define_mci_rule( NEW_LEVEL, COMMENT_LINE, lr, "//" "\r" );
define_mci_rule( NEW_LEVEL, COMMENT, bd, "/**" "*/", overlay b );
define_mci_rule( NEW_LEVEL, COMMENT_LINE, lnd, "///" "\n" );
define_mci_rule( NEW_LEVEL, COMMENT_LINE, lrd, "///" "\r" );

// String rules
define_mci_rule( NEW_LEVEL, STRING, c, quote quote ); // simple character
define_mci_rule( NEW_LEVEL, STRING, cb, quote quote, prefix "b" ); // byte character
define_mci_rule( NEW_LEVEL, STRING, s, double_quotes double_quotes, overlay v ); // simple string
define_mci_rule( NEW_LEVEL, STRING, sb, "\"\"\"" "\"\"\"", overlay v ); // string block
define_mci_rule( NEW_LEVEL, STRING, sw, double_quotes double_quotes, prefix "w", overlay v ); // wide string
//define_mci_rule( NEW_LEVEL, STRING, sr, double_quotes double_quotes, prefix "r", rep_delimiter "(" ")" ); // raw string
//define_mci_rule( NEW_LEVEL, STRING, srw, double_quotes double_quotes, prefix "wr", rep_delimiter "(" ")" ); // wide raw string

// Additional normal code rules
define_mci_rule( NEW_LEVEL, NORMAL, n, overlay b ln lr bd lnd lrd c sb s sb sw sr srw ); // normal code (root)
//define_mci_rule( NEW_LEVEL, NORMAL, v, "\\(" ")" ); // value extraction in strings

// Special basic literals
//define_mci_rule( NEW_OPERATOR, std::literal::bin_integer, 1, ltr, triple_list, "0", "b", integer -> value ); // binary radix
//define_mci_rule( NEW_OPERATOR, std::literal::oct_integer, 1, ltr, triple_list, "0", "o", integer -> value ); // octal radix
//define_mci_rule( NEW_OPERATOR, std::literal::hex_integer, 1, ltr, triple_list, "0", "x", integer -> value ); // hexadecimal radix
define_mci_rule( NEW_OPERATOR, std::literal::float, 1, ltr, triple_list, integer -> lvalue, ".", integer -> rvalue ); // simple float
define_mci_rule( NEW_OPERATOR, std::literal::float_exp, 1, ltr, quintuple_list, integer -> lvalue, ".", integer -> rvalue, "e", integer -> expo ); // float with positive exponent
define_mci_rule( NEW_OPERATOR, std::literal::float_exp, 1, ltr, quintuple_list, integer -> lvalue, ".", integer -> rvalue, "E", integer -> expo ); // float with positive exponent
define_mci_rule( NEW_OPERATOR, std::literal::float_exp_neg, 1, ltr, sextuple_list, integer -> lvalue, ".", integer -> rvalue, "e", "-", integer -> expo ); // float with negative exponent
define_mci_rule( NEW_OPERATOR, std::literal::float_exp_neg, 1, ltr, sextuple_list, integer -> lvalue, ".", integer -> rvalue, "E", "-", integer -> expo ); // float with negative exponent

/*
// Special statements
define_mci_rule( ALIAS_EXPRESSION, double_list, "use", expr -> new_identifier ); // use-statement begins with the keyword "use" and ends with an assignment of the new identifier.
define_mci_rule( LET_STATEMENT, double_list, "let", expr -> new_identifier ); // let keyword which starts a new variable binding
define_mci_rule( SELF_EXPRESSION, single_list, "self" ); // the self keyword is the currently executed object in non-static methods

// OOP constructs
define_mci_rule( STRUCT_DEFINITION, triple_list, "struct", identifier -> new_identifier, expr -> body ); // struct declarations are defined by the keyword "struct", a identifier and the following body.
define_mci_rule( STRUCT_DEFINITION, single_list, "struct" ); // anonymous struct
define_mci_rule( TRAIT_DEFINITION, triple_list, "trait", identifier -> new_identifier, expr -> body ); // trait declarations start with the "trait" keyword, then the new traits' name and the body with its method.
define_mci_rule( IMPL_DEFINITION, triple_list, "impl", identifier -> type, expr -> body ); // impl-blocks which defines methods for a struct independent of a trait
define_mci_rule( IMPL_DEFINITION, quintuple_list, "impl", identifier -> trait, "for", identifier -> type, expr -> body ); // impl-blocks which defines a trait for a struct

// Control flow
define_mci_rule( IF_EXPRESSION, triple_list, "if", expr -> condition, expr -> exec0 ); // if expressions/statements are defined with the keyword "if" a condition expression and a executable block
define_mci_rule( IF_ELSE_EXPRESSION, quintuple_list, "if", expr -> condition, expr -> exec0, "else", expr -> exec1 ); // if-else expressions/statements are defined with the keyword "if" a condition expression, a executable block, the "else" keyword and a alternative executable block
define_mci_rule( WHILE_EXPRESSION, triple_list, "while", expr -> condition, expr -> exec ); // regular while loop
define_mci_rule( FOR_EXPRESSION, triple_list, "for", expr -> condition, expr -> exec ); // for loop over an iterator
define_mci_rule( MATCH_EXPRESSION, triple_list, "match", expr -> selector, expr -> body ); // match keyword which matches an expression
*/

// Functions
//define_mci_rule( FUNCTION_DECLARATION, std::op::Function, fn, double_list, identifier -> name, expr -> parameters ); // a function head
define_mci_rule( FUNCTION_DEFINITION, std::op::Function, fn, double_list, identifier -> name, expr_block -> body ); // a zero-parameter function with a body block
define_mci_rule( FUNCTION_DEFINITION, std::op::Function, fn, triple_list, identifier -> name, expr -> parameters, expr_block -> body ); // a function with a body block
//define_mci_rule( FUNCTION_DEFINITION, std::op::Function, fn, quadruple_list, identifier -> name, expr -> parameters, "->", expr -> body ); // a single-line function

// Appending operations
//define_mci_rule( DEFINE_TEMPLATE, 1, ltr, triple_list, "<" -> lop, identifier -> value, ">" -> rop ); // template arguments are surrounded by angular brackets
define_mci_rule( SCOPE_ACCESS, 1, ltr, triple_list, expr -> base, "::" -> op, expr -> name ); // scope access is a symbol extension
define_mci_rule( SCOPE_ACCESS, 1, rtl, double_list, "::" -> op, expr -> name ); // global scope access
define_mci_rule( MEMBER_ACCESS, 1, ltr, triple_list, expr -> base, "." -> op, expr -> name ); // member access of a object
//define_mci_rule( ARRAY_SPECIFIER, 1, ltr, triple_list, "[" -> lop, expr -> value, "]" -> rop ); // array appending to a type or variable. The size may be a number or a static variable, etc.

// Operators
// NEW_OPERATOR parameters: global function (full symbol name; parameters are applied based on layout type), precedence, alignment(ltr or rtl), syntax type (double_list, etc.), syntax parameters (normally multiple)
//define_mci_rule( NEW_OPERATOR, std::op::function_call, 1, ltr, quadruple_list, identifier -> exec, "(" -> lop, expr -> parameters, ")" -> rop ); // function calls surround their parameters in parenthesis

 define_mci_rule( NEW_OPERATOR, std::op::log_not, 2, rtl, double_list, "!" -> op, expr -> value ); // define the logical not operator
 define_mci_rule( NEW_OPERATOR, std::op::invert, 2, rtl, double_list, "~" -> op, expr -> value ); // define the not/invert operator
 define_mci_rule( NEW_OPERATOR, std::op::negate, 2, rtl, double_list, "-" -> op, expr -> value ); // define the negation operator
 define_mci_rule( NEW_OPERATOR, std::op::positive, 2, rtl, double_list, "+" -> op, expr -> value ); // define the positive operator (only for symmetry with the negation operator)
 define_mci_rule( NEW_OPERATOR, std::op::increment_prefix, 2, rtl, double_list, "++" -> op, expr -> value ); // define the prefix increment operator
 define_mci_rule( NEW_OPERATOR, std::op::decrement_prefix, 2, rtl, double_list, "--" -> op, expr -> value ); // define the prefix decrement operator
 define_mci_rule( NEW_OPERATOR, std::op::increment_postfix, 3, ltr, double_list, expr -> value, "++" -> op ); // define the postfix increment operator
 define_mci_rule( NEW_OPERATOR, std::op::decrement_postfix, 3, ltr, double_list, expr -> value, "--" -> op ); // define the postfix decrement operator
define_mci_rule( NEW_OPERATOR, std::op::cast_from, 4, ltr, triple_list, expr -> lvalue, "as" -> op, expr -> rvalue ); // define the From cast with the as keyword
define_mci_rule( NEW_OPERATOR, std::op::cast_into, 4, ltr, triple_list, expr -> lvalue, "as" -> op, expr -> rvalue ); // define the Into cast with the as keyword

define_mci_rule( NEW_OPERATOR, std::op::multiplication, 5, ltr, triple_list, expr -> lvalue, "*" -> op, expr -> rvalue ); // basic multiplication operator
define_mci_rule( NEW_OPERATOR, std::op::division, 5, ltr, triple_list, expr -> lvalue, "/" -> op, expr -> rvalue ); // basic division operator
define_mci_rule( NEW_OPERATOR, std::op::remain, 5, ltr, triple_list, expr -> lvalue, "%" -> op, expr -> rvalue ); // basic remaining operator
define_mci_rule( NEW_OPERATOR, std::op::addition, 6, ltr, triple_list, expr -> lvalue, "+" -> op, expr -> rvalue ); // basic addition operator
define_mci_rule( NEW_OPERATOR, std::op::subtraction, 6, ltr, triple_list, expr -> lvalue, "-" -> op, expr -> rvalue ); // basic subtraction operator

define_mci_rule( NEW_OPERATOR, std::op::bit_and, 7, ltr, triple_list, expr -> lvalue, "&" -> op, expr -> rvalue ); // basic bit "and" operator
define_mci_rule( NEW_OPERATOR, std::op::bit_xor, 8, ltr, triple_list, expr -> lvalue, "\'" -> op, expr -> rvalue ); // basic bit xor operator
define_mci_rule( NEW_OPERATOR, std::op::bit_or, 9, ltr, triple_list, expr -> lvalue, "|" -> op, expr -> rvalue ); // basic bit or operator
define_mci_rule( NEW_OPERATOR, std::op::bit_shift_left, 10, ltr, triple_list, expr -> lvalue, "<<" -> op, expr -> rvalue ); // basic left bit shift operator
define_mci_rule( NEW_OPERATOR, std::op::bit_shift_right, 10, ltr, triple_list, expr -> lvalue, ">>" -> op, expr -> rvalue ); // basic right bit shift operator

define_mci_rule( NEW_OPERATOR, std::op::iterate_collection, 11, ltr, triple_list, expr -> lvalue, "in" -> op, expr -> rvalue ); // iteration over a collection

define_mci_rule( NEW_OPERATOR, std::op::smaller, 12, ltr, triple_list, expr -> lvalue, "<" -> op, expr -> rvalue ); // regular compare
define_mci_rule( NEW_OPERATOR, std::op::smaller_or_eql, 12, ltr, triple_list, expr -> lvalue, "<=" -> op, expr -> rvalue ); // regular compare (with or eaual)
define_mci_rule( NEW_OPERATOR, std::op::bigger, 12, ltr, triple_list, expr -> lvalue, ">" -> op, expr -> rvalue ); // inverse compare
define_mci_rule( NEW_OPERATOR, std::op::bigger_or_eql, 12, ltr, triple_list, expr -> lvalue, ">=" -> op, expr -> rvalue ); // inverse compare (with or eaual)
define_mci_rule( NEW_OPERATOR, std::op::is_equal, 13, ltr, triple_list, expr -> lvalue, "==" -> op, expr -> rvalue ); // equality comarison
define_mci_rule( NEW_OPERATOR, std::op::is_not_equal, 13, ltr, triple_list, expr -> lvalue, "!=" -> op, expr -> rvalue ); // inequality comarison

define_mci_rule( NEW_OPERATOR, std::op::logic_and, 14, ltr, triple_list, expr -> lvalue, "&&" -> op, expr -> rvalue ); // basic logical "and" operator
define_mci_rule( NEW_OPERATOR, std::op::logic_or, 15, ltr, triple_list, expr -> lvalue, "||" -> op, expr -> rvalue ); // basic logical or operator

define_mci_rule( NEW_OPERATOR, std::op::assignment, 16, rtl, triple_list, expr -> lvalue, "=" -> op, expr -> rvalue ); // simple assignment
define_mci_rule( NEW_OPERATOR, std::op::add_assign, 16, rtl, triple_list, expr -> lvalue, "+=" -> op, expr -> rvalue ); // simple add assignment
define_mci_rule( NEW_OPERATOR, std::op::subtract_assign, 16, rtl, triple_list, expr -> lvalue, "-=" -> op, expr -> rvalue ); // simple subtract assignment
define_mci_rule( NEW_OPERATOR, std::op::multiply_assign, 16, rtl, triple_list, expr -> lvalue, "*=" -> op, expr -> rvalue ); // simple multiply assignment
define_mci_rule( NEW_OPERATOR, std::op::divide_assign, 16, rtl, triple_list, expr -> lvalue, "/=" -> op, expr -> rvalue ); // simple divide assignment
define_mci_rule( NEW_OPERATOR, std::op::remain_assign, 16, rtl, triple_list, expr -> lvalue, "%=" -> op, expr -> rvalue ); // simple remain assignment
define_mci_rule( NEW_OPERATOR, std::op::and_assign, 16, rtl, triple_list, expr -> lvalue, "&=" -> op, expr -> rvalue ); // simple bit and assignment
define_mci_rule( NEW_OPERATOR, std::op::xor_assign, 16, rtl, triple_list, expr -> lvalue, "\'=" -> op, expr -> rvalue ); // simple bit xor assignment
define_mci_rule( NEW_OPERATOR, std::op::or_assign, 16, rtl, triple_list, expr -> lvalue, "|=" -> op, expr -> rvalue ); // simple bit or assignment
define_mci_rule( NEW_OPERATOR, std::op::shift_left_assign, 16, rtl, triple_list, expr -> lvalue, "<<=" -> op, expr -> rvalue ); // simple left bit shift assignment
define_mci_rule( NEW_OPERATOR, std::op::shift_right_assign, 16, rtl, triple_list, expr -> lvalue, ">>=" -> op, expr -> rvalue ); // simple right bit shift assignment
define_mci_rule( NEW_OPERATOR, std::op::default_assign, 16, rtl, triple_list, expr -> lvalue, ":=" -> op, expr -> rvalue ); // simple default operator assignment

define_mci_rule( NEW_OPERATOR, std::op::relation, 17, rtl, triple_list, expr -> lvalue, "=>" -> op, expr -> rvalue ); // pair two variables with a relation
//define_mci_rule( NEW_OPERATOR, std::op::comma_combine, 18, lrt, triple_list, expr -> lvalue, "," -> op, expr -> rvalue ); // the comma-linking operator
//define_mci_rule( NEW_OPERATOR, std::op::comma_end, 18, lrt, double_list, expr -> value, "," -> op ); // the comma-linking operator which enables a ending comma in e. g. structs

define_mci_rule( REFERENCE_TYPE, 2, rtl, double_list, "&" -> op, expr -> type ); // syntax to define a reference or destruct a reference
define_mci_rule( TYPE_OF, 2, rtl, double_list, "type_of" -> op, expr -> type ); // define the type_of operator
define_mci_rule( STRUCT_TO_TUPLE, 2, ltr, double_list, expr -> type, "as_tuple" -> op ); // define the as_tuple operator
define_mci_rule( OPERATION_TYPE, 4, ltr, triple_list, expr -> value, ":" -> op, expr -> type ); // define the type operator
define_mci_rule( RANGE_DEFINITION_EXC, 10, ltr, triple_list, expr -> lvalue, ".." -> op, expr -> rvalue ); // define the range operator for 0..5
define_mci_rule( RANGE_DEFINITION_FROM_EXC, 10, ltr, double_list, expr -> value, ".." -> op ); // define the range operator 5..
define_mci_rule( RANGE_DEFINITION_TO_EXC, 10, ltr, double_list, ".." -> op, expr -> value ); // define the range operator for ..5
define_mci_rule( RANGE_DEFINITION_INC, 10, ltr, triple_list, expr -> lvalue, "..=" -> op, expr -> rvalue ); // define the range operator for 0..=5
define_mci_rule( RANGE_DEFINITION_TO_INC, 10, ltr, double_list, "..=" -> op, expr -> rvalue ); // define the range operator for ..=5

// Primitive types
define_mci_rule( INTEGER_TRAIT, std::num::Integer ); // Defines which trait describes the integer type

define_mci_rule( SPECIAL_TYPE, TYPE, "type" ); // definition of the "type" type
define_mci_rule( SPECIAL_TYPE, NEVER, "!" ); // definition of the "!" type
define_mci_rule( SPECIAL_TYPE, UNIT, "()" ); // define the unit-type
define_mci_rule( SPECIAL_TYPE, UNKNOWN, "_" ); // define the unknown type
define_mci_rule( SPECIAL_TYPE, IDENTIFIER, "ident" ); // define the "identifier" type
define_mci_rule( SPECIAL_TYPE, SELF, "Self" ); // define the "self" type

define_mci_rule( TYPE_MEMORY_BLOB, "bool", 1 );
define_mci_rule( TYPE_MEMORY_BLOB, "char", 1 );
define_mci_rule( TYPE_MEMORY_BLOB, "char8", 1 );
define_mci_rule( TYPE_MEMORY_BLOB, "usize", 4 );
define_mci_rule( TYPE_MEMORY_BLOB, "isize", 4 );

define_mci_rule( TYPE_MEMORY_BLOB, "i8", 1 );
define_mci_rule( TYPE_MEMORY_BLOB, "i16", 2 );
define_mci_rule( TYPE_MEMORY_BLOB, "i32", 4 );
define_mci_rule( TYPE_MEMORY_BLOB, "i64", 8 );
define_mci_rule( TYPE_MEMORY_BLOB, "i128", 16 );
define_mci_rule( TYPE_MEMORY_BLOB, "i256", 32 );
define_mci_rule( TYPE_MEMORY_BLOB, "u8", 1 );
define_mci_rule( TYPE_MEMORY_BLOB, "u16", 2 );
define_mci_rule( TYPE_MEMORY_BLOB, "u32", 4 );
define_mci_rule( TYPE_MEMORY_BLOB, "u64", 8 );
define_mci_rule( TYPE_MEMORY_BLOB, "u128", 16 );
define_mci_rule( TYPE_MEMORY_BLOB, "u256", 32 );
define_mci_rule( TYPE_MEMORY_BLOB, "f32", 4 );
define_mci_rule( TYPE_MEMORY_BLOB, "f64", 8 );
define_mci_rule( TYPE_MEMORY_BLOB, "f128", 16 );
define_mci_rule( TYPE_MEMORY_BLOB, "f256", 32 );

// Special literals
define_mci_rule( NEW_LITERAL, "true", "bool", 1 );
define_mci_rule( NEW_LITERAL, "false", "bool", 0 );
